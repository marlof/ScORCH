##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## These functions manage the manager/view screen
## fn_SkipFailed()
## fn_Manager()
## fn_ShowPrefs()
## fn_Admin()
## fn_ViewJob()
## fn_EditJob()
## fn_Cancel()
## fn_AdminFunctions()
## fn_CatchWord()
## fn_Filter()

fn_SkipFailed()
{
  int_Count=1
  int_Last=$(grep "^AUDIT:T:*:" ${file_Job} | cut -d: -f 3 | sort -n | tail -1)
  declare -A JOB
  while (( int_Count <= int_Last )) ; do
    echo JOB[T${int_Count}]=$(grep "^AUDIT:T:${int_Count}:" ${file_Job} | tail -1 | cut -d: -f4)
    JOB[T${int_Count}]=$(grep "^AUDIT:T:${int_Count}:" ${file_Job} | tail -1 | cut -d: -f4)
    (( int_Count++ ))
  done

  int_Count=1
  while (( int_Count <= int_Last )) ; do
    [[ "F" == "${JOB[T${int_Count}]}" ]] && echo "AUDIT:T:${int_Count}:S" >> ${file_Job}
    (( int_Count++ ))
  done
}

fn_Filter()
{
  printf "\n\n"
  [[ ! -z ${str_Filter} ]] && printf " Current filter <${str_Filter}> (press enter to clear)\n\n"
  read -t ${int_Refresh} -p " Job name filter string: " str_Filter || :
  #str_Filter=$(echo ${str_Filter})
}
readonly -f fn_Filter

fn_Manager()
{
  typeset local char_Choice=
  tput rmam
  hex_MD5=$(md5sum ${dir_Base}/${str_ProgramName} | cut -d" " -f1)
  trap ':' SIGWINCH
  while : ; do
    fn_CheckMaint

    fn_ShowTop
    fn_ShowJobs superseded manual failed fixing new running starting pending queued completed
    fn_ShowLine "="
    fn_DisplayMOTD
    printf "\n${dis_Reset}"
    fn_ContextMenu
    (( b_Quick == 1 )) && str_Quick="-n 1" || str_Quick=""


    read ${str_Quick} -t ${int_Refresh} char_Choice || :

    case ${char_Choice} in

      ## Admin Menu
      a | A ) fn_Admin ;;

      ## Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p "${dir_Plugins}/." -j "${dir_Job}/." ; fn_SetLayout ;;

      ## Job State transition
      d | D ) fn_Transition delete  ;;
      q | Q ) fn_Transition queue    ; fn_CheckDispatcher ;;
      r | R ) fn_Transition resume   ; fn_CheckDispatcher ;;
      u | U ) fn_Transition unqueue ;;
      p | P ) fn_Transition pause   ;;

      ## Misc
      t | T ) fn_ShowTasks          ;;
      f | F ) fn_Filter             ;;
      x | X ) break ;;

      ## Releases
      [0-9]* ) (( b_Quick )) && fn_CatchWord ${char_Choice} "number" || fn_AdminFunctions ${char_Choice} ;;

#      o | O ) 
#         read -e -t ${int_Refresh} char_ChoiceExtra
#         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
#         case ${str_Choice} in
#            open       ) fnE_MkOpenScorch ;;
#         esac  ;;

#      e | E )
#         read -e -t ${int_Refresh} char_ChoiceExtra
#         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
#         case ${str_Choice} in
#            enterprise ) fnE_MkEscorchtar ;;
#         esac  ;;

#      s | S )
#         read -e -t ${int_Refresh} char_ChoiceExtra
#         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
#         fn_CheckDispatcher
#         case ${str_Choice} in
#            set )   fnE_Set ;;
#         esac  ;;

      * ) fn_SetLayout ;;

    esac
  fn_RunJobs
  done
  tput smam
}
readonly -f fn_Manager

fn_ShowPrefs()
{
  while : ; do
    ${cmd_CLEAR}
    fn_ShowTop
    fn_ShowLine
    if [[ -f ${file_Prefs} ]] ; then
      printf "\n\n"
      fn_ShowLine "-" " Prefs ${file_Prefs}"
      cat ${file_Prefs}
      fn_ShowLine
    fi
    echo ""
    fn_ShowLine "="
    printf "\n "
    printf "${dis_ULOn}E${dis_ULOff}dit Preferences | "
    printf "${dis_ULOn}D${dis_ULOff}efaults | "
    printf " e${dis_ULOn}X${dis_ULOff}it : "

    read ${str_Quick} -t ${int_Refresh} char_Choice || :

    case ${char_Choice} in
      e | E ) ${cmd_Editor} ${file_Prefs} ; source ${file_Prefs} ;;
      d | D ) [[ -w ${file_Prefs} ]] && fn_Confirm "Reset preferences" && rm ${file_Prefs} && fn_SetPrefs ;;
      x | X ) return 0 ;;
      *     ) return 0 ;;
    esac
  done
}

#fn_ShowMOTD()
#{
#  ${cmd_CLEAR}
#  fn_ShowTop
#  fn_ShowLine
#  echo ""
#  fn_ShowLine "-" "Message of the day"
#  fn_DisplayMOTD
#  echo ""
#  fn_ShowLine "="
#  printf "\n"
# # printf "${dis_ULOn}M${dis_ULOff}OTD | "
#  printf "e${dis_ULOn}X${dis_ULOff}it : "#
#
#  read ${str_Quick} -t ${int_Refresh} char_Choice

#  case ${char_Choice} in
#    m | M ) fn_EditMOTD  ;;
#    x | X ) return 0 ;;
#    *     ) return 0 ;;
#  esac
#}

#typeset    str_ProgramName="$(basename "$0")"
#typeset            dir_Run="$(dirname "$0")"
#typeset           dir_Orig="$(pwd)/${dir_Run}"

fn_Admin()
{
  while : ; do
  ${cmd_CLEAR}
  fn_ShowTop
  fn_ShowLine
  printf "\n"
  printf " C) Check for latest online version       ${str_LatestVersion}\n\n"

  # POWER User Features
  # fn_FileOwner ${dir_Base}:${str_ProgramName}\n $(fn_FileOwner ${dir_Base}/${str_ProgramName}) == ${str_User}\n\n"
  if (( b_Power == 1 )) ; then
    printf " B) Build a tar release                   ${dir_Base}/escorch.${str_ProgramVersion}.tar\n\n"
    printf " L) View and Delete locks %5s           %s\n\n" "($(ls ${dir_Lock} | wc -l))" ${dir_Lock}
    [[ "${str_LatestVersion}" != "check" ]] && printf " I) Install latest version                ${str_LatestVersion}\n\n"
    printf " S) Suspend all sessions (Maintenance)    %s\n\n" ${file_Maint}
    printf " F) Function Plugin Manager\n\n"
    printf " D) Download Plugins\n\n"
    [[ "${str_LatestVersion}" != "check" ]] && printf " R) Repair Permissions\n\n"
  else
    printf " POWER User permissions required:\n"
    printf "   .) Build Tar\n"
    printf "   .) Locks\n"
    printf "   .) Install\n"
    printf "   .) Maintenace\n\n"
    printf "   .) Function Plugins Manager"
    printf "   .) Download Plugins"
  fi



#  if [[ "${str_LatestVersion}" != "check" ]] ; then
#    if [[ "$(fn_FileOwner ${dir_Base}/${str_ProgramName})" == "${str_User}" ]] && (( b_Power == 1 )) ; then
#      printf " I) Install latest version                ${str_LatestVersion}\n\n"
#    else
#      printf " .) Only a POWER user owner <$(fn_FileOwner ${dir_Base}/${str_ProgramName})> can install\n\n"
#    fi
#  fi



  printf " P) Edit Display and Timing Preferences %s\n\n" ${file_Prefs}
  printf " M) Change the message of the day         %s\n\n" ${file_MOTD}
  printf " V) View the CSV audit file               %s\n\n" ${file_CSV}
  #fn_ShowLine "-" "Message of the day"
  #fn_DisplayMOTD
  fn_ShowLine "="
  fn_DisplayMOTD
  printf "\n"
  (( b_Power == 1 )) && printf "${dis_ULOn}B${dis_ULOff}uild Release | "
  printf "${dis_ULOn}C${dis_ULOff}heck Version | "
  [[ "${str_LatestVersion}" != "check" ]] && (( b_Power == 1 )) && printf "${dis_ULOn}I${dis_ULOff}nstall ${str_LatestVersion} | ${dis_ULOn}R${dis_ULOff}epair | "
  printf "${dis_ULOn}P${dis_ULOff}references | "
  printf "${dis_ULOn}M${dis_ULOff}essage | "
  (( b_Power == 1 )) && printf "${dis_ULOn}L${dis_ULOff}ocks | "
  (( b_Power == 1 )) && printf "${dis_ULOn}S${dis_ULOff}upend | "
  (( b_Power == 1 )) && printf "${dis_ULOn}F${dis_ULOff}unctions | "
  (( b_Power == 1 )) && printf "${dis_ULOn}D${dis_ULOff}ownload | "

  printf "${dis_ULOn}V${dis_ULOff}iew CSV | "    
  printf " e${dis_ULOn}X${dis_ULOff}it : "

  read ${str_Quick} -t ${int_Refresh} char_Choice || :

  case ${char_Choice} in
    b | B ) (( b_Power == 1 ))      && fnE_MkEscorchtar ;;
    c | C )                            fn_CheckLatest ;;
    i | I ) (( b_Power == 1 ))      && fn_InstallLatest  ;;
    m | M ) (( b_Restricted != 1 )) && fn_AdminMOTD  ;;
    p | P )                            fn_ShowPrefs ;; #${cmd_Editor} ${file_Prefs} ; source ${file_Prefs} ;;
    l | L ) (( b_Power == 1 ))      && fn_LockManager        ;;
    d | D ) fn_Plugins ;;

    f | F ) (( b_Power == 1 ))      && fnE_PluginManagerMenu ;;

    r | R ) (( b_Power == 1 ))      && fn_Repair ;;
    s | S ) (( b_Power == 1 ))      && ln -s ${str_ProgramName}.${str_User} ${file_Maint} ;;
    ## View CSV
    v | V ) ${cmd_Editor} "${file_CSV}" ;;
    x | X ) return 0 ;;
    *     ) return 0 ;;

  esac
  done
}

fn_ViewJob()
{
  typeset local file_Orig="$1"
  typeset local file_View="${file_Orig}.$$"
  cp "${file_Orig}" "${file_View}"
  ${cmd_Editor} "${file_View}"
  if ! diff "${file_Orig}" "${file_View}" ; then
    printf "\n\nWarning. Not in edit mode. Changes will not be saved.\n"
    read ${str_Quick} -p "Do you want to save your changes to /tmp? [y/n] " char_Answer || :
    printf "\n\n"
    if [[ "${char_Answer}" = "y" ]] || [[ "${char_Answer}" = "Y" ]] ; then
      mv "${file_View}" /tmp/$(basename "${file_Orig}")
      fn_Audit "${file_Orig}" "saved an edited copy of job and saved a copy in /tmp"
    fi
  #fn_PressEnter
  fi
  [ -f "${file_View}" ] && rm -f "${file_View}" || :
}
readonly -f fn_ViewJob

fn_EditJob()
{
  typeset local file_Orig="$1"
  fn_CheckOwner "${file_Orig}"
  typeset local file_Edit="${file_Orig}.$$"
  cp "${file_Orig}" "${file_Edit}"
  ${cmd_Editor} "${file_Edit}"
  if ! diff "${file_Orig}" "${file_Edit}" ; then
    mv "${file_Edit}" "${file_Orig}"
    fn_Audit "${file_Orig}" "edited job"
  fi
  [ -f "${file_Edit}" ] && rm -f "${file_Edit}" || :
}
readonly -f fn_EditJob

fn_Cancel()
{
  typeset local    file_Link="$1"
  typeset local str_JobState="$2"
  typeset local     file_Log="${dir_Log}/$(basename ${file_Link})".log

  fn_CheckOwner "${file_Link}"
  echo "${file_Link}"
  if [[ "${str_JobState}" = "running" ]] ; then
    printf "From AUDIT PID:"
    int_PID=$(grep "^AUDIT:PID:" ${file_Log} | tail -1 | cut -d: -f3)
#    ps -fu ${str_User} | grep $(basename ${file_Link}) | grep -v bash | grep -v grep
#    int_PID=$(ps -fu ${str_User} | grep $(basename ${file_Link}) | grep -v grep | awk -F" " '{print $2}')
#    echo ${int_PID} 
    echo "Processes running at termination:" >> ${file_Log}
    ps -fu ${str_User} >> ${file_Log}
    echo "Process tree at termination:" >> ${file_Log}
    pstree -p ${int_PID} >> ${file_Log}
    printf "\n Killing Process with PID[${int_PID}]\n"
    grep "^AUDIT:T:.*:R" ${file_Link} 
    int_KillTask=$(grep "^AUDIT:T:.*:R" ${file_Link} | tail -1 | cut -d: -f3)
    kill ${int_PID}
    mv ${file_Link} ${dir_Failed}
    fn_Audit "${file_Link}" "Job killed during task ${int_KillTask}. Resume point:${int_KillTask}"
    fn_LogWhy
  elif  [[ "${str_JobState}" = "failed"  ]] || [[ "${str_JobState}" = "manual"  ]]; then
    int_KillTask=$(grep "^AUDIT:T:.*:" ${file_Link} | tail -1 | cut -d: -f3)
    mv ${file_Link} ${dir_Completed}
    fn_LogWhy
    fn_Audit "${file_Link}" "aborted during task ${int_KillTask:-0}"
    printf "\n\n Aborted Job : ${file_Link}"
  else
    echo "Incorrect call"
  fi
  fn_PressEnter
}

fn_AdminFunctions()
{
  typeset local char_Choice=${1}
  if [[ ${char_Choice} -gt 0 ]] && [[ ${char_Choice} -lt ${int_Count} ]] ; then

  ##if [[ ${char_Choice} -lt ${int_Count} ]] ; then

    typeset         str_JobState="${arr_States[${char_Choice}]}"
    typeset local       file_Job="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local      file_Link="${dir_Job}/${str_JobState}/${arr_Jobs[${char_Choice}]}"
    typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local       file_Log="${dir_Log}/$(basename ${file_Job})".log
    while : ; do
      fn_JobInfo
      type fnE_RulesMenu >/dev/null 2>&1 && fnE_RulesMenu
      fn_ContextMenu ${str_JobState}
      read ${str_Quick} -t 30 char_Choice || :
      fn_CheckDispatcher


      case ${char_Choice} in

        ## Abort Failed or Running jobs
        h | H ) fn_Cancel "${file_Link}" "${str_JobState}" ;;

        ## View CSV
        #c | C ) ${cmd_Editor} "${file_CSV}" ;;

        ## Edit job
        v | V ) fn_ViewJob "${file_ActiveJob}" ;;
        e | E ) fn_EditJob "${file_ActiveJob}" ;;
                #fn_CheckOwner "${file_ActiveJob}"
                #${cmd_Editor} "${file_ActiveJob}" ;;
        l | L ) ${cmd_Editor} "${file_Log}" ;;

        ## Job State transition

        ## Delete Job(s)
        d | D ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" deleted
                echo ",,,$(date +%s),$(basename ${file_Job}),,,-1,${str_User}" >> "${file_CSV}"
                mv "${file_Link}" "${dir_Deleted}"
                return 0 ;;

        ## Queue Job(s)
        q | Q ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" queued
                fn_UpdateResumePoint "${file_Job}" 0
                if [ -r "${dir_Active}/$(basename ${file_Job})".rules ] ; then
                  mv "${file_Link}" "${dir_Pending}"
                else
                  mv "${file_Link}" "${dir_Queued}"
                fi
                return 0 ;;

        ## Resume Job(s)
        r | R ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
                mv "${file_Link}" "${dir_Queued}"
                return 0 ;;

        ## Skip a task in Job(s)
        s | S ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"
                fn_SkipFailed "${file_Job}"
                #echo "AUDIT:T:${int_Task}:S" >> "${file_Jobh}"

                mv "${file_Link}" "${dir_Queued}"
                return 0 ;;

        ## Pause Job(s)
        p | P ) fn_CheckOwner "${file_ActiveJob}"
                if [ -f "${dir_Active}"/"$(basename "${file_Job}").pause" ] ; then
                  rm "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause removed. Current task will continue"
                else
                  touch "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause set. Current task will not complete"
                fi
                fn_LogWhy		
                return 0 ;;

        ## Unqueue Job(s) back to New State
        u | U ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" unqueued
                mv "${file_Link}" "${dir_New}"  
                return 0 ;;

        ## Task View

        ## Mark Job as Fix in Progress (FIP)
        f | F ) echo " "
                read -e -p " You may provide a keyword or tracking id: " str_Reply
                [[ ! -z ${str_Reply} ]] && str_Reply=" [${str_Reply}]"
                fn_Audit "${file_Job}" "fix in progress"
                mv "${file_Link}" "${dir_Fixing}"
                echo "$(${fn_LogDate}) Fix in progress${str_Reply}. Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}"
                return 0 ;;

        ## Amend Job rules
        c | C ) fnE_AmendRules        ;;
       # t     ) fn_CatchWord ${char_Choice} "tail tasks" ;;
        t*    ) if (( b_Quick )); then
                  fn_CatchWord ${char_Choice} "tail tasks"
                else
                  if [[ ${char_Choice} == "t" ]] ; then
                    fn_ShowTasks "${file_Job}"
                  elif [[ ${char_Choice} == "tail" ]] ; then
                    trap "return 0" 2 ; tail -f "${file_Log}"
                  fi
                fi
                  ;;

        x | X ) return 0 ;;
        *     ) return 0 ;;
      esac
    done
  else 
    echo "Out of range"
    fn_PressEnter
  fi
  fn_SetLayout
}
readonly -f fn_AdminFunctions

fn_CatchWord()
{
  local char_ChoiceExtra="$1"
  local arr_WordList="$2"
  local int_Length=1
  local str_Word=${char_ChoiceExtra}
  local int_Del=1
  while  [ "${char_ChoiceExtra}" != "" ]  ; do
    read -n 1 -t 30 char_ChoiceExtra
    if [ "${char_ChoiceExtra}" = "" ] ; then
      int_Length=${#str_Word} 
      int_Del=$(( int_Length - 1 )) 
      if (( int_Del >= 0 )) ; then
        eval str_Word=\${str_Word:0:${int_Del}}
        printf "\b \b\b \b"
        # Oracle printf "\b\b\b   \b\b\b"
      else
        printf "\b \b"
        # Oracle printf "\b\b  \b\b"
        continue
      fi
    else
      str_Word=${str_Word}${char_ChoiceExtra}
    fi
  done
  # To be extended
  case ${str_Word} in
    t | T      ) fn_ShowTasks "${file_Job}"          ;;
    tail       ) trap "return 0" 2 ; tail -f "${file_Log}" ;;
    [0-9]*     ) fn_AdminFunctions ${str_Word}  ;;
    *          ) ${cmd_CLEAR} ;;
  esac
  #echo "${str_Word}"
}
