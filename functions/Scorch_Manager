##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## These functions manage the manager/view screen
## fn_Manager()
## fn_ShowPrefs()
## fn_Admin()
## fn_ViewJob()
## fn_EditJob()
## fn_Cancel()
## fn_AdminFunctions()
## fn_CatchWord()


fn_Manager()
{
  typeset local char_Choice=
  tput rmam
  hex_MD5=$(md5sum ${dir_Base}/${str_ProgramName} | cut -d" " -f1)
  trap ':' SIGWINCH
  while : ; do
    fn_ShowTop
    fn_ShowJobs superseded failed fixing new running starting pending queued completed
    fn_ShowLine "="
    fn_DisplayMOTD
    printf "\n${dis_Reset}"
    fn_ContextMenu
    (( b_Quick == 1 )) && str_Quick="-n 1" || str_Quick=""


    read ${str_Quick} -t ${int_Refresh} char_Choice

    case ${char_Choice} in

      ## Admin Menu
      a | A ) fn_Admin ;;

      ## Create a new job
      n | N ) "${dir_Base}"/${str_ProgramName} -new -p "${dir_Plugins}/." -j "${dir_Job}/." ; fn_SetLayout ;;


      ## Job State transition
      d | D )                          fn_Transition delete  ;;
      q | Q ) fn_CheckDispatcher     ; fn_Transition queue   ;;
      r | R ) fn_CheckDispatcher     ; fn_Transition resume  ;;
      u | U )                          fn_Transition unqueue ;;
      p | P )                          fn_Transition pause   ;;
      i | I )                          fnE_PluginManagerMenu ;;

      ## Misc
      #m | M ) fn_EditMOTD           ;;
      #l | L ) fn_LockManager        ;;
      t | T ) fn_ShowTasks          ;;
      x | X ) break ;;


      ## Releases
      [0-9]* ) (( b_Quick )) && fn_CatchWord ${char_Choice} "number" || fn_AdminFunctions ${char_Choice} ;;

      o | O ) 
         read -e -t ${int_Refresh} char_ChoiceExtra
         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
         case ${str_Choice} in
            open       ) fnE_MkOpenScorch ;;
         esac  ;;

      e | E )
         read -e -t ${int_Refresh} char_ChoiceExtra
         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
         case ${str_Choice} in
            enterprise ) fnE_MkEscorchtar ;;
         esac  ;;

      s | S )
         read -e -t ${int_Refresh} char_ChoiceExtra
         str_Choice="${char_Choice,,}${char_ChoiceExtra,,}"
         fn_CheckDispatcher
         case ${str_Choice} in
            set )   fnE_Set ;;
         esac  ;;

      * ) fn_SetLayout ;;

    esac
	fn_RunJobs
  done
  tput smam
}
readonly -f fn_Manager

fn_ShowPrefs()
{
  while : ; do
    ${cmd_CLEAR}
    fn_ShowTop
    fn_ShowLine
    if [[ -f ${file_Prefs} ]] ; then
      printf "\n\n"
      fn_ShowLine "-" " Prefs ${file_Prefs}"
      cat ${file_Prefs}
      fn_ShowLine
    fi
    echo ""
    fn_ShowLine "="
    printf "\n "
    printf "${dis_ULOn}E${dis_ULOff}dit Preferences | "
    printf "${dis_ULOn}D${dis_ULOff}efaults | "
    printf " e${dis_ULOn}X${dis_ULOff}it : "

    read ${str_Quick} -t ${int_Refresh} char_Choice

    case ${char_Choice} in
      e | E ) ${cmd_Editor} ${file_Prefs} ; source ${file_Prefs} ;;
      d | D ) [[ -w ${file_Prefs} ]] && rm ${file_Prefs} && fn_SetPrefs ;;
      x | X ) return 0 ;;
      *     ) return 0 ;;
    esac
  done
}

#fn_ShowMOTD()
#{
#  ${cmd_CLEAR}
#  fn_ShowTop
#  fn_ShowLine
#  echo ""
#  fn_ShowLine "-" "Message of the day"
#  fn_DisplayMOTD
#  echo ""
#  fn_ShowLine "="
#  printf "\n"
# # printf "${dis_ULOn}M${dis_ULOff}OTD | "
#  printf "e${dis_ULOn}X${dis_ULOff}it : "#
#
#  read ${str_Quick} -t ${int_Refresh} char_Choice

#  case ${char_Choice} in
#    m | M ) fn_EditMOTD  ;;
#    x | X ) return 0 ;;
#    *     ) return 0 ;;
#  esac
#}


fn_Admin()
{
  while : ; do

  ${cmd_CLEAR}
  fn_ShowTop
  fn_ShowLine
  printf "\n"
  printf " P) Change Display and Timing preferences %s\n\n" ${file_Prefs}
  printf " M) Change the message of the day         %s\n\n" ${file_MOTD}
  printf " L) View and Delete locks %5s           %s\n\n" "($(ls ${dir_Lock} | wc -l))" ${dir_Lock}
  printf " V) View the CSV audit file               %s\n\n" ${file_CSV}
  #fn_ShowLine "-" "Message of the day"
  #fn_DisplayMOTD
  fn_ShowLine "="
  fn_DisplayMOTD
  printf "\n"
  printf "${dis_ULOn}P${dis_ULOff}references | "
  printf "${dis_ULOn}M${dis_ULOff}essage | "
  printf "${dis_ULOn}L${dis_ULOff}ocks | "
  printf "${dis_ULOn}V${dis_ULOff}iew CSV | "    
  printf " e${dis_ULOn}X${dis_ULOff}it : "

  read ${str_Quick} -t ${int_Refresh} char_Choice

  case ${char_Choice} in
    m | M ) fn_AdminMOTD  ;;
    p | P ) fn_ShowPrefs ;; #${cmd_Editor} ${file_Prefs} ; source ${file_Prefs} ;;
    l | L ) fn_LockManager        ;;
    ## View CSV
    v | V ) ${cmd_Editor} "${file_CSV}" ;;
    x | X ) return 0 ;;
    *     ) return 0 ;;

  esac
  done
}

fn_ViewJob()
{
  typeset local file_Orig="$1"
  typeset local file_View="${file_Orig}.$$"
  cp "${file_Orig}" "${file_View}"
  ${cmd_Editor} "${file_View}"
  if ! diff "${file_Orig}" "${file_View}" ; then
    printf "\n\nWarning. Not in edit mode. Changes will not be saved.\n"
	  read ${str_Quick} -p "Do you want to save your changes to /tmp? [y/n] " char_Answer
	  printf "\n\n"
	  if [[ "${char_Answer}" = "y" ]] || [[ "${char_Answer}" = "Y" ]] ; then
	    mv "${file_View}" /tmp/$(basename "${file_Orig}")
      fn_Audit "${file_Orig}" "saved an edited copy of job and saved a copy in /tmp"
    fi
	#fn_PressEnter
  fi
  [ -f "${file_View}" ] && rm -f "${file_View}"
}
readonly -f fn_ViewJob

fn_EditJob()
{
  typeset local file_Orig="$1"
  fn_CheckOwner "${file_Orig}"
  typeset local file_Edit="${file_Orig}.$$"
  cp "${file_Orig}" "${file_Edit}"
  ${cmd_Editor} "${file_Edit}"
  if ! diff "${file_Orig}" "${file_Edit}" ; then
	  mv "${file_Edit}" "${file_Orig}"
    fn_Audit "${file_Orig}" "edited job"
  fi
  [ -f "${file_Edit}" ] && rm -f "${file_Edit}"
}
readonly -f fn_EditJob

fn_Cancel()
{
  typeset local    file_Link="$1"
  typeset local str_JobState="$2"
  typeset local     file_Log="${dir_Log}/$(basename ${file_Link})".log

  fn_CheckOwner "${file_Link}"
  if [[ "${str_JobState}" = "running" ]] ; then
    printf "From AUDIT PID:"
    int_PID=$(grep "^AUDIT:PID:" ${file_Log} | tail -1 | cut -d: -f3)
#    ps -fu ${str_User} | grep $(basename ${file_Link}) | grep -v bash | grep -v grep
#    int_PID=$(ps -fu ${str_User} | grep $(basename ${file_Link}) | grep -v grep | awk -F" " '{print $2}')
#    echo ${int_PID} 
    echo "Processes running at termination:" >> ${file_Log}
    ps -fu ${str_User} >> ${file_Log}
    echo "Process tree at termination:" >> ${file_Log}
    pstree -p ${int_PID} >> ${file_Log}
    printf "\n Killing Process with PID[${int_PID}]"
    kill ${int_PID}
    mv ${file_Link} ${dir_Failed}
    int_KillTask=$(grep "^AUDIT:T:.*:R" ${file_Log} | tail -1 | cut -d: -f3)
    fn_Audit "${file_Link}" "Job killed during task ${int_KillTask}. Resume point:${int_KillTask}"
  elif  [[ "${str_JobState}" = "failed"  ]] ; then
    fn_Audit "${file_Link}" "Aborted"
    mv ${file_Link} ${dir_Completed}
    printf "\n\n Aborted Job : ${file_Link}"
  else
    echo "Incorrect call"
  fi
  fn_PressEnter
}

fn_AdminFunctions()
{
  typeset local char_Choice=${1}
  if [[ ${char_Choice} -gt 0 ]] && [[ ${char_Choice} -lt ${int_Count} ]] ; then

  ##if [[ ${char_Choice} -lt ${int_Count} ]] ; then

    typeset         str_JobState="${arr_States[${char_Choice}]}"
    typeset local       file_Job="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local      file_Link="${dir_Job}/${str_JobState}/${arr_Jobs[${char_Choice}]}"
    typeset local file_ActiveJob="${dir_Active}/${arr_Jobs[${char_Choice}]}"
    typeset local       file_Log="${dir_Log}/$(basename ${file_Job})".log
    while : ; do
      fn_JobInfo
      type fnE_RulesMenu >/dev/null 2>&1 && fnE_RulesMenu
      fn_ContextMenu ${str_JobState}
      read ${str_Quick} -t 30 char_Choice
      fn_CheckDispatcher


      case ${char_Choice} in
	
        ## Abort Failed or Running jobs
        c | C ) fn_Cancel "${file_Link}" "${str_JobState}" ;;

        ## View CSV
        #c | C ) ${cmd_Editor} "${file_CSV}" ;;

        ## Edit job
        v | V ) fn_ViewJob "${file_ActiveJob}" ;;
        e | E ) fn_EditJob "${file_ActiveJob}" ;;
		        #fn_CheckOwner "${file_ActiveJob}"
                #${cmd_Editor} "${file_ActiveJob}" ;;
        l | L ) ${cmd_Editor} "${file_Log}" ;;

        ## Job State transition
		
        ## Delete Job(s)
        d | D ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" deleted
                echo ",,,$(date +%s),$(basename ${file_Job}),,,-1,${str_User}" >> "${file_CSV}"
                mv "${file_Link}" "${dir_Deleted}"
                return 0 ;;

        ## Queue Job(s)
        q | Q ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" queued
                fn_UpdateResumePoint "${file_Job}" 0
                if [ -r "${dir_Active}/$(basename ${file_Job})".rules ] ; then
                  mv "${file_Link}" "${dir_Pending}"
                else
                  mv "${file_Link}" "${dir_Queued}"
                fi
                return 0 ;;

        ## Resume Job(s)
        r | R ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "resumed task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" $(fn_GetResumePoint ${file_Log})
                mv "${file_Link}" "${dir_Queued}"
                return 0 ;;

        ## Skip a task in Job(s)
        s | S ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" "skipped task:$(fn_GetResumePoint ${file_Log} ) "
                fn_LogWhy
                fn_UpdateResumePoint "${file_Job}" "$(( $(fn_GetResumePoint ${file_Log}) + 1 ))"

                #echo "AUDIT:T:${int_Task}:S" >> "${file_Jobh}"

                mv "${file_Link}" "${dir_Queued}"
                return 0 ;;

        ## Pause Job(s)
        p | P ) fn_CheckOwner "${file_ActiveJob}"
                if [ -f "${dir_Active}"/"$(basename "${file_Job}").pause" ] ; then
                  rm "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause removed. Current task will continue"
                else
                  touch "${dir_Active}"/"$(basename "${file_Job}").pause"
                  fn_Audit "${file_Job}" "pause set. Current task will not complete"
                fi
                fn_LogWhy		
                return 0 ;;

        ## Unqueue Job(s) back to New State
        u | U ) fn_CheckOwner "${file_ActiveJob}"
                fn_Audit "${file_Job}" unqueued
                mv "${file_Link}" "${dir_New}"  
                return 0 ;;

        ## Task View

        ## Mark Job as Fix in Progress (FIP)
        f | F ) echo " "
                read -e -p " You may provide a keyword or tracking id: " str_Reply
                [[ ! -z ${str_Reply} ]] && str_Reply=" [${str_Reply}]"
                fn_Audit "${file_Job}" "fix in progress"
                mv "${file_Link}" "${dir_Fixing}"
                echo "$(${fn_LogDate}) Fix in progress${str_Reply}. Resume Point:$(fn_GetResumePoint "${file_Log}" )" >> "${file_Log}"
                return 0 ;;

        ## Amend Job rules
        a | A ) fnE_AmendRules        ;;
        t     ) fn_CatchWord ${char_Choice} "tail tasks" ;;
        x | X ) return 0 ;;
        *     ) return 0 ;;
      esac
    done
  else 
    echo "Out of range"
    fn_PressEnter
  fi
  fn_SetLayout
}
readonly -f fn_AdminFunctions

fn_CatchWord()
{
  local char_ChoiceExtra="$1"
  local arr_WordList="$2"
  local int_Length=1
  local str_Word=${char_ChoiceExtra}
  local int_Del=1
  while  [ "${char_ChoiceExtra}" != "" ]  ; do
    read -n 1 -t 30 char_ChoiceExtra
    if [ "${char_ChoiceExtra}" = "" ] ; then
      int_Length=${#str_Word} 
      int_Del=$(( int_Length - 1 )) 
      if (( int_Del >= 0 )) ; then
        eval str_Word=\${str_Word:0:${int_Del}}
        printf "\b \b\b \b"
        # Oracle printf "\b\b\b   \b\b\b"
      else
        printf "\b \b"
        # Oracle printf "\b\b  \b\b"
        continue
      fi
    else
      str_Word=${str_Word}${char_ChoiceExtra}
    fi
  done
  # To be extended
  case ${str_Word} in
    t | T      ) fn_ShowTasks "${file_Job}"          ;;
    tail       ) trap "return 0" 2 ; tail -f "${file_Log}" ;;
    [0-9]*     ) fn_AdminFunctions ${str_Word}  ;;
    *          ) ${cmd_CLEAR} ;;
  esac
  #echo "${str_Word}"
}
