##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## This file contains functions to set and display layout
## fn_Dispatcher()
## fn_CheckRunning()
## fn_CheckDispatcher()
## fn_RunJobs()
## fn_LockManager()


fn_Dispatcher()
{
  typeset local int_DispatchCount=0

  ## Run the dispatcher loop for a predetermined number of times
  while [ ${int_DispatchCount} -lt ${int_DispatchMax} ] ; do
    ## Repair any missing lock file for dispatcher
    ## [[ ! -L ${file_DispatchLock} ]] && ln -s ${str_User}_$$ "${file_DispatchLock}"
    ## Make sure all current jobs reporting a running state are actually running
    fn_CheckMaint

    fn_CheckRunning
    sleep ${int_DispatchSleep}

    ## #83 - make sure jobs directories exists - if not then exit
    [[ ! -d "${dir_Pending}" ]] || [[ ! -d "${dir_Running}" ]] || [[ ! -d "${dir_Queued}"  ]] && exit 1

    ## Check the pending directory first for any rules that have succeeded
    typeset local arr_PendingJobs=$(ls -rt1 "${dir_Pending}")
    if [[ "${arr_PendingJobs}" ]] ; then

      for file_EachJob in ${arr_PendingJobs} ; do
        echo "Checking rules for $file_EachJob"
        if [ -r "${dir_Active}/$(basename ${file_EachJob})".rules ] ; then
          ## Check for Parent
          arr_Parents=$(grep "PARENT:" "${dir_Active}/$(basename ${file_EachJob})".rules | cut -d: -f2)

          typeset local b_ParentComplete=0
          for file_EachParent in ${arr_Parents} ; do
            if [[ "${file_EachParent}" = "${file_EachJob}" ]] ; then
               fn_Audit "${file_EachJob}" "Cyclic dependency. Failing job" "rules"
               mv ${dir_Pending}/${file_EachJob} ${dir_Failed}
            fi

            str_ParentState=$(basename $(dirname $(find -L ${dir_Job} -name ${file_EachParent} | grep -v "/active/")))

            case ${str_ParentState} in
              completed ) fn_Audit "${file_EachJob}" "Parent job ${file_EachParent} completed." "rules" ;;
              superseded | failed )                          b_ParentComplete=1 ;;
              running | starting | pending | queued | new  ) b_ParentComplete=1 ;;
              *       )   fn_Audit "${file_EachJob}" "RULES: Parent job ${file_EachParent} missing. Moving job to failed state."   "rules"
                          b_ParentComplete=1
                          mv "${dir_Pending}/${file_EachJob}" "${dir_Failed}" ;;

            esac
          done
          if [[ "${b_ParentComplete}" = 0 ]] ; then
            fn_Audit "${file_EachJob}" "All parent jobs completed. Moving job to queued state." "rules"
            mv "${dir_Pending}/${file_EachJob}" "${dir_Queued}"
          fi
        fi
      done
      ## If there are any pending jobs (with valid rules) we must keep the dispatcher running
      int_DispatchCount=0
    fi

    ## Move queued jobs to start state
    ## Job lock example: JobLock.DEMO-GROUP2_ST1  ->  Job_ID-251_251.DEMO-GROUP2.1_DEMO-GROUP2_ST1_
    typeset local arr_QueuedJobs=$(ls -rt1 "${dir_Queued}")
  	if [[ "${arr_QueuedJobs}" ]] ; then
      for file_EachJob in ${arr_QueuedJobs} ; do
        str_QueueLock=$(echo "${file_EachJob}" | ${cmd_AWK} -F"_" '{print $4"_"$5}')
        file_QueueLock="${file_JobLock}.${str_QueueLock}"
        if [ ! -L "${file_QueueLock}" ] ; then
          ln -s "${file_EachJob}" "${file_QueueLock}"
          echo "$(${fn_LogDate}) Dispatch: ${file_EachJob}" >> "${file_DispatchLog}"
          mv "${dir_Queued}/${file_EachJob}" "${dir_Starting}"
          int_DispatchCount=0
        else
          ## Check that for every env lock file that there is a job in a non finish state
          ## (failed, completed, deleted, new)
          typeset local arr_JobLocks=$(ls "${file_JobLock}"*)
          for file_EachLock in ${arr_JobLocks} ; do
            [[ "$(find -L ${dir_Job}/running ${dir_Job}/starting -name $(ls -l "${file_EachLock}" | ${cmd_AWK} -F" " '{print $NF}'))" ]] || rm "${file_EachLock}"
          done
        fi
        sleep 1
      done
    fi
    (( int_DispatchCount+=1 ))
    #sleep ${int_DispatchSleep}
  done
  rm -f "${file_DispatchLock}"
  typeset int_DispatcherPID=0
  exit 0
}
readonly -f fn_Dispatcher

fn_CheckRunning()
{
  ## Check running jobs are really running
  ## If they are not, move them to a failed state and report they were orphaned
  typeset local arr_RunningJobs=$(ls -t1 "${dir_Running}" | grep -v "pause$" 2>/dev/null)
  if [[ "${arr_RunningJobs}" ]] ; then
    for file_EachJob in ${arr_RunningJobs} ; do
      if [ ! "$(ps -ef | grep ${file_EachJob} | grep -v grep)" ] ; then
        mv "${dir_Running}/${file_EachJob}" "${dir_Failed}/."
        echo "$(${fn_LogDate}) Orphaned. Resume point:unknown" | tee -a "${dir_Active}/${file_EachJob}" "${dir_Log}/${file_EachJob}.log"
      fi
    done
  fi
}
readonly -f fn_CheckRunning

fn_CheckDispatcher()
{
  ## Check Dispatcher
##  typeset local int_DispatcherPID=$(ls -l "${dir_Lock}/${str_ProgramName}.lck" 2>/dev/null | cut -d_ -f2)
  [ -f "${file_DispatchLock}" ] && ( [[ "$(ls -l "${file_DispatchLock}" | ${cmd_AWK} -F"_" '{print $NF}')" ]] || rm "${file_DispatchLock}" )
  if [ -L "${file_DispatchLock}" ] ; then
    ## Check the lock is correct
    #echo "Checking this pid $$ against lock pid $(ls -l "${file_DispatchLock}" | awk -F"_" '{print $NF}')"
    if [[ $(pgrep -f "${str_ProgramName} -dispatcher -j ${dir_Job}" | head -1) -eq $(ls -l "${file_DispatchLock}" | ${cmd_AWK} -F"_" '{print $NF}') ]] ; then
      #echo This is the dispatcher      
      return 0
    else
      #echo This is not the dispatcher      
      rm "${file_DispatchLock}" 2>/dev/null
    fi
  else
    if [[ "$(pgrep -f "${str_ProgramName} -dispatcher -j ${dir_Job}")" ]] ; then
      ln -s "${dir_Base}/${str_ProgramName}_$(pgrep -f "${str_ProgramName} -dispatcher -j ${dir_Job}")" "${file_DispatchLock}"	  
      return 0
    else
      "${dir_Base}/${str_ProgramName}" -dispatcher -j "${dir_Job}" >> "${file_DispatchLog}" &
      ln -s "${dir_Base}/${str_ProgramName}_$!" "${file_DispatchLock}"
    fi
  fi
}
readonly -f fn_CheckDispatcher

fn_RunJobs()
{
  ## Run owned jobs in START state
  ##ls "${dir_Starting}"
  ##shopt -s nullglob
  ##for file_EachJob in $(ls -tr "${dir_Starting}"/* 2>/dev/null)  ; do
  for file_EachJob in $(grep -l "str_Owner=${str_User}" "${dir_Starting}"/* 2>/dev/null)  ; do
    printf "\n$(${fn_LogDate}) Starting $(basename "${file_EachJob}")"
    fn_CreateFile "${dir_Log}"/$(basename "${file_EachJob}").log
    if [[ -x "${file_EachJob}" ]] ; then
      if [[ -z ${str_Group} ]] ; then
        nohup "${file_EachJob}" </dev/null >> "${dir_Log}"/$(basename "${file_EachJob}").log 2>&1 &
      else
        newgrp ${str_Group} << EOGROUP
        nohup "${file_EachJob}" </dev/null >> "${dir_Log}"/$(basename "${file_EachJob}").log 2>&1 &
EOGROUP
      fi
    else
      ## Fail the job as not executable
      #echo "Job not executable - running with bash"
      if [[ -z ${str_Group} ]] ; then
        nohup /bin/bash "${file_EachJob}" </dev/null >> "${dir_Log}"/$(basename "${file_EachJob}").log 2>&1 &
      else
        newgrp ${str_Group} << EOGROUP
        nohup /bin/bash "${file_EachJob}" </dev/null >> "${dir_Log}"/$(basename "${file_EachJob}").log 2>&1 &
EOGROUP
      fi
    fi
    ## To ensure started in order
    sleep 1
  done
}
readonly -f fn_RunJobs

fn_LockManager()
{
  ## An easier way to check locks
  while : ; do
    fn_ShowTop
    fn_ShowLine
    int_Count=1
    for file_Lock in $(ls ${dir_Lock}) ; do
      printf "${dis_Reset}${str_StatusColour}%${int_Column1Width}s | "   "${int_Count}"
      printf "${file_Lock} -> $(ls -l ${dir_Lock}/${file_Lock} | cut -d ">" -f2)\n"
      arr_Locks[${int_Count}]="${file_Lock}"
      (( int_Count+=1 ))
    done
    if [[ ${int_Count} -lt 2 ]] ; then
      printf "\n\n No locks active\n\n"
      fn_ShowLine "="
      fn_PressEnter
      return 0
    else
      fn_ShowLine "="

      printf "\n Select job number lock to delete | e${dis_ULOn}X${dis_ULOff}it : "

      read -e -t 30 char_Choice
      [[ "${char_Choice}" = "" ]] && char_Choice="x"
      case "${char_Choice}" in

        ## Lock transition
        d | D ) printf "rm lock "  ;;
        [0-9]* ) echo "removing ${dir_Lock}/${arr_Locks[${char_Choice}]}" ; rm "${dir_Lock}/${arr_Locks[${char_Choice}]}" ; sleep 2 ;;

        x | X ) return 0 ;;
      esac
    fi
  ##  fn_RunJobs
  done
}
readonly -f fn_LockManager
