#
# Copyright 2016 WebMarcIT Ltd
#
# Unauthorised copying of this file, via any medium is strictly prohibited
# This is the proprietary software of WebMarcIT Ltd
# Written by marc@webmarcit.com

fn_GetRequest()
{
  ## Receive the request from a file or interactively
  typeset local file_Template="${1:-}"
  typeset local str_Line=""
  typeset local int_GetCount=1

  ## global tmp file
  file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
  fn_CreateFile "${file_Request}"

  if [ ! -z "${file_Template}" ] ; then
    echo "$($fn_LogDate): Processing file:${file_Template}"
    while read -r str_Line ; do
          str_ULine=$(echo ${str_Line} | tr [:lower:] [:upper:])
      [[ ${str_ULine} =~ ACTION ]] &&  (( int_GetCount+=1 )) && file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
      echo "${str_Line}" | grep ":" >> "${file_Request}"
    done < "${file_Template}"
  else
    printf "\n help <plugin>    at any time for additional parameters\n\n"
    printf " Please enter the request below.\n To complete the request is use a fullstop on a newline:\n (To quit type CANCEL)\n\n"
    while [[ "${str_Line}" != "." ]] ; do
      read -e -r str_Line
          str_ULine=$(echo ${str_Line} | tr [:lower:] [:upper:])
##      if echo "${str_Line}" | grep -qi ACTION ; then
##        (( int_GetCount+=1 ))
##        file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
##      fi
      if [[  ${str_ULine} =~ HELP ]] ; then
        typeset local str_Help=${str_Line#help }
        if [[ "${str_Line}" ]] ; then
          echo "==SYSTEM============="
          declare -f fn_ExtractPairs | grep "GetVar -pattern"
          echo "==CUSTOM============="
          declare -f "SP_${str_Help}" | grep "GetVar "
          echo "==============="
        fi
      else
        [[ ${str_ULine} =~ CANCEL ]] && rm ${dir_Tmp}/${str_ProgramName}.$$.[0-9]* && break
        [[ ${str_ULine} =~ ACTION ]] &&  (( int_GetCount+=1 )) && file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_GetCount}
        echo "${str_Line}" | grep ":" >> "${file_Request}"
      fi
    done
  fi
}
readonly -f fn_GetRequest

fn_ProcessRequest()
{
  typeset local int_JobCount=1
  typeset local int_FileCount=1

  int_JobID=$(fn_GetJobID)

  for str_EachFile in ${dir_Tmp}/${str_ProgramName}.$$.* ; do
    [[ -e ${str_EachFile} ]] || break
    file_Request=${dir_Tmp}/${str_ProgramName}.$$.${int_FileCount}
    echo "${str_EachFile}"

    fn_ExtractPairs

    [[ "${b_Debug}" ]] && echo "Action: ${ACTION}"
    for ACTION in ${ACTION_LIST} ; do
      for ENVIRONMENT in ${ENVIRONMENT_LIST} ; do

        int_TaskCount=0
        if type -t "SP_${ACTION}" >/dev/null ; then
          fn_Call="SP_${ACTION}"
        else
          printf "\n\nCannot find a function called SP_${ACTION} or ${fn_Call}\n"
          fn_PressEnter
          return 0
        fi
        str_Call=${fn_Call#SP_}
                [[ ! -z "${LABEL}" ]]  && str_Label="${LABEL}" || str_Label="${ACTION}"
        file_Job="${dir_New}"/${str_JobPrefix}${TICKET}_${int_JobID}.${str_Label}.${int_JobCount}_${str_Call}_${ENVIRONMENT}_${RELEASE}
        if [[ ! -z "${PARENT_LIST}" ]] ; then
          for str_EachRule in ${PARENT_LIST} ; do
            echo "PARENT:${str_JobPrefix}${TICKET}_${int_JobID}.${str_EachRule}.*" >> "${dir_Active}/$(basename "${file_Job}")".rules
          done
        fi
        fn_JobHeader "${file_Job}"
        Task "echo AUDIT:START:\${str_StartTime}"
printf "${fn_Call}: "
        ${fn_Call}

        int_ReturnCode=${PIPESTATUS[0]}
        # PIPESTATUS AND USE PIPE TEE
        if [[ ${int_ReturnCode} -ne 0 ]] ; then
          echo "exit 1" >> "${file_Job}"
          echo "# Template Begin" >> "${file_Job}"
          cat "${file_Request}" >> "${file_Job}"
          echo "# Template End" >> "${file_Job}"
          echo "$(${fn_LogDate}) Error in plugin. Task creation not complete" >> "${dir_Log}"/$(basename "${file_Job}").log
          mv "${file_Job}" "${dir_Failed}"/.
          fn_PressEnter
          exit 1
        fi
echo " $((int_TaskCount--)) tasks created" ; sleep 3
        fn_JobFooter "${file_Job}"
        echo "$(${fn_LogDate}) Created by:${str_User} Tasks[${int_TaskCount}]" >> "${dir_Log}"/$(basename "${file_Job}").log
        (( int_JobCount+=1 ))
        b_StartGroup=""

        if [[ $(ls "${dir_Failed}"/"${str_JobPrefix}*_${ACTION}_${ENVIRONMENT}*" 2>/dev/null)  ]] ; then
           mv "${dir_Failed}"/"${str_JobPrefix}*_${ACTION}_${ENVIRONMENT}*" "${dir_Superseded}"/.
        fi
        [[ ${b_Start} ]] && mv "${file_Job}" "${dir_Queued}/."

      done
    done
    (( int_FileCount++ ))
    rm "${file_Request}"
  done
}
readonly -f fn_ProcessRequest

fn_ShowRules()
{
  ## typeset local file_Job="${1}"
  echo ""
  [[ -r ${file_ActiveJob}.rules ]] && ( fn_ShowLine "-" "Rules" ; cat ${file_ActiveJob}.rules ; echo "" )
}
readonly -f fn_ShowRules

fnE_Rules()
{
  fn_PressEnter
}
readonly -f fnE_Rules

fnE_RulesMenu()
{
  ## printf "\n\n Rules menu "
  printf " ${dis_ULOn}A${dis_ULOff}mend rules |"
}
readonly -f fnE_RulesMenu

fnE_AmendRules()
{
  fn_ShowTop
  fn_ShowLine "-" "File details"
  echo ""
  ls -lL "${file_ActiveJob}"
  ls -lL "${file_Log}"
  echo ""
  fn_ShowRules
  fn_ShowLine "-"

  printf "\n\n "
  printf " ${dis_ULOn}A${dis_ULOff}dd parent | ${dis_ULOn}D${dis_ULOff}elete rules  | e${dis_ULOn}X${dis_ULOff}it : "

  read ${str_Quick} -t 60 char_Choice

  case ${char_Choice} in

          a | A ) fn_ShowJobs2 failed running starting pending queued new
               fn_ShowLine
               fn_GetAnswer
               echo "PARENT:${arr_Jobs[${str_Answer}]}" >> ${file_ActiveJob}.rules ;;

          d | D ) rm ${file_ActiveJob}.rules
                  # if link to active job in pending mv job to queued
                           ;;

          ## Edit job
          x | X ) return 0 ;;
          *     ) return 0 ;;
  esac

}
readonly -f fnE_AmendRules

fn_ExtractPairs()
{
  GetVar -pattern "From"    -name FROM
  GetVar -pattern "Sent"    -name SENT
  GetVar -pattern "Action"  -name ACTION_LIST      -list
  GetVar -pattern "Release" -name RELEASE                -default ""
  GetVar -pattern "Enviro"  -name ENVIRONMENT_LIST -list -default "NA"
  GetVar -pattern "Type"    -name TYPE                   -default ""
  GetVar -pattern "Ticket"  -name TICKET                 -default "ID-${int_JobID}"  

  GetVar -pattern "Label"  -name LABEL                   -default ""
  GetVar -pattern "Parent" -name PARENT_LIST -list       -default ""
}
readonly -f fn_ExtractPairs

fn_CheckAuth()
{
  ## This function is stubbed for future enhancements
  ## The idea is that users will need to be allowed to use scorch as a reporting tool
  ## or be allowed access to certain systems/plugin directories

  ##  #Username  : [ full | <blank> ] : [ all | <comma separated list of plugin dirs>]
  ##     marc:full:all
  ##     root::all
  ##     user::demo
  file_Users=${dir_Etc}/users

  if [[ ${b_Install} ]] ; then
    printf "\n\n\tInitialising....\n\n"
    [ ! -f ${file_Users} ] && echo "${str_User}:FULL:ALL" > ${file_Users}
  fi

  printf "\nChecking authority: "
  if [ ! -r ${file_Users} ] ; then
    if [ -f ${file_Users} ] ; then
      echo "The file ${file_Users} is not readable."
      ls -l ${file_Users}
      exit 1
    else
      echo "The users file does not exist. Create the users file ${file_Users}"
      exit 1
    fi
  fi

  grep "^${str_User}:" ${file_Users}
  str_Authority=$(grep "^${str_User}:" ${file_Users} | cut -d":" -f2 | tr [:lower:] [:upper:])
  case ${str_Authority} in
    P | POWER ) b_Power=1 ;      str_Authority="Power User" ;;
    R | REST* ) b_Restricted=1 ; str_Authority="View Only"  ;;
    F | FULL  )                  str_Authority="Normal"     ;;
    *         ) printf "\n${str_Authority}: Authority Level not set correctly.\nCheck with the ${str_ProgramName} administrator.\n" ; exit 1 ;;
  esac
}
