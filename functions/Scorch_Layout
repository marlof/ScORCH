##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## This file contains functions to set and display layout
## fn_SetLayout()
## fn_ShowTop()
## fn_ShowLine()
## fn_ShowJobs2()
## fn_DisplayTime()
## fn_ShowJobs3()
## fn_FormatTasks()
## fn_ShowTasks()
## fn_JobInfo()
## fn_ContextMenu()


fn_SetLayout()
{
  ## Define the bounds of the screen
  ## The default screen layout is broken into columns to split up job names into
  ## meaningful groups
  ##
  ##  C1|     C2|        C3|        C4|
  ##==========================================================
  ##    |       |          |          |
  int_ScreenWidth=$(${cmd_TPUT} cols)
  ## echo ${int_ScreenWidth}
  #int_ScreenWidth=${COLUMNS}

  # Purposely set one per line to cope with white space in directory names
  arr_Checks="
    ${dir_New}
    ${dir_Completed}
    ${dir_Failed}
    ${dir_Running}"

  int_Column1Width=4        # Selection number
  int_Column2Width=8        # System reference number (like JIRA) or use ticket number
  SAVEIFS=$IFS
  IFS=$(echo -en "\n\b")
  (( int_Column3Width=$(find -L ${dir_Active} | ${cmd_AWK} -F"_" '{print length($4)}' | sort -un | tail -1) +1 ))
  (( int_Column4Width=$(find -L ${dir_Active} | ${cmd_AWK} -F"_" '{print length($5)}' | sort -un | tail -1) +1 ))
  (( int_Column5Width=$(find -L ${dir_Active} ! -name "*.rules" | ${cmd_AWK} -F"_" '{print length($6)}' | sort -un | tail -1) +1 ))
  (( int_Column6Width=$(find -L ${dir_Active} | ${cmd_AWK} -F"_" '{print length($7)}' | sort -un | tail -1) +1 ))
  IFS=$SAVEIFS
#int_Column2Width=16
#int_Column3Width=12 #${int_Column3Width:-20}       # The Action / Plugin
#int_Column4Width=10       # The Environment performed on
#int_Column5Width=10       # The Version / Release being actioned
#int_Column6Width=10       # Available

  int_Column7Width=10       # The Log
  cha_ColumnSep="|"
}
readonly -f fn_SetLayout


fn_ShowTop()
{
  ## Display the name of the program and any interesting facts about the environment
  ## ===============================================================================
  typeset local int_TitleWidth
  [[ -z ${int_Column1Width} ]] && int_Column1Width=10
  [[ -z ${int_Column2Width} ]] && int_Column2Width=10
  (( int_TitleWidth=${int_Column1Width} + ${int_Column2Width} ))
  ${cmd_CLEAR}

  ## Check the current width of the screen
  ## =====================================
  int_ScreenWidth=$(${cmd_TPUT} cols)
  #int_ScreenWidth=${COLUMNS}
  ##(( int_DateLocation=${int_ScreenWidth} - ${int_TitleWidth} - ${int_Column2Width} - ${int_Column3Width} - 20 ))
  (( int_DatePut = ${int_ScreenWidth} - 21 ))

  ## Collect disk usage to display
  ##int_DiskUsage=$(df "${dir_Base}" |  ${cmd_AWK} 'NR==2 {sub(/%/,""); if ($5 > 44 ) print ""$5"" else print $5}')
  int_DiskUsage=$(df "${dir_Base}" |  ${cmd_AWK} 'NR==2 {sub(/%/,""); if ($5 > 80 ) {
                                        print "${dis_FRed}"$5"%${dis_Reset}" }
                                          else {
                                            print $5"%"
                                                                          }
                                      printf "" }')
  ## Output the program name, the dispatcher PID and the date
  typeset int_DispatcherPID=$(ls -l "${file_DispatchLock}" 2>/dev/null | ${cmd_AWK} -F"_" '{print $NF}')
  int_DispatcherPID=${int_DispatcherPID:-0}
  printf " %${int_TitleWidth}s|%${int_Column3Width}s|%${int_Column4Width}s|%${int_Column6Width}s|%s" \
         "${str_ProgramName} [${str_ProgramVersion}]" \
         "D:${int_DispatcherPID}" \
                 "${int_DiskUsage}" "${str_License}" "${str_Authority}"
  [[ ${cmd_TPUT} != "echo" ]] && tput cup 0 ${int_DatePut} ; echo "$(date +'%D %T')"


  ## Reset the Array for Jobs and States
  ## ===================================
  unset arr_Jobs arr_States
}
readonly -f fn_ShowTop

fn_ShowLine()
{
  ## Show a line of dashes unless a different character is past or character and title is passed

  ## Check if parameters have been past
  ## ==================================
  typeset local cha_LineChar=${1:-"-"}
  typeset local str_LineTitle=${2:-$cha_LineChar}

  ## Find the width of the title
  ## ===========================
  typeset local int_LineTitleWidth=$(echo ${str_LineTitle} | wc -c)

  ## Set the number of characters required to the correct width
  ## ==========================================================
  (( int_DisplayWidth = ${int_ScreenWidth}-${int_LineTitleWidth} - 4 ))
  printf "${dis_Reset}   ${str_LineTitle} %${int_DisplayWidth}s\n" | sed "s/ /${cha_LineChar}/g"

}
readonly -f fn_ShowLine

fn_ShowJobs()
{
    if [ -f ${dir_Python}/showJobs.py ] ; then
      ${dir_Python}/showJobs.py -n $int_MaxShown -o ${file_Cache} $* 
      [[ -r ${file_Cache} ]] && . ${file_Cache}
    else
      fn_ShowJobs2
    fi
}

fn_ShowJobs2()
{
  ## Show job details for each job state past. The value passed is one or more directory names
  ## =========================================================================================
  typeset local str_EachJobState= arr_JobList= str_StatusColour=""
  typeset local str_StatusColour="${dis_Reset}"

  ## Due to the fact that directories may contain "spaces" so "cd" there first
  ## =========================================================================
  cd "${dir_Job}"
  int_Count=1

  file_Cache=$(mktemp "${dir_Tmp}"/cache.$$.XXXXX)
  echo "#$$" > "${file_Cache}"
  int_ScreenWidth=$(echo ${COLUMNS})
  int_ScreenWidth=$(tput cols)
  for str_State in ${@} ; do
    printf "${dis_Reset}"

    [[ "${str_State}" = "failed"  ]] && str_StatusColour="${dis_BRed}" || str_StatusColour="${dis_Reset}"
    [[ "$(ls ${str_State}/${str_JobPrefix}* 2>/dev/null)" ]] && fn_ShowLine "-" "$(echo ${str_State} | tr [:lower:] [:upper:])"
    [[ "${str_State}" != "completed" ]] && str_Reverse="r" || str_Reverse=""
#echo "$(pwd)"
#echo "${file_Cache}"
    ls -${str_Reverse}t "${str_State}/${str_JobPrefix}"* 2>/dev/null | grep -v "pause$" | ${cmd_AWK} \
      -v            state=${str_State} \
      -v             user=${str_User} \
      -v          linenum=${int_Count} \
      -v          dir_Log="${dir_Log}" \
      -v       dir_Active="${dir_Active}" \
      -v       file_Cache="${file_Cache}" \
      -v           Colour=${str_StatusColour} \
      -v  int_ScreenWidth=${int_ScreenWidth} \
      -v int_Column1Width=${int_Column1Width} \
      -v int_Column2Width=${int_Column2Width} \
      -v int_Column3Width=${int_Column3Width} \
      -v int_Column4Width=${int_Column4Width} \
      -v int_Column5Width=${int_Column5Width} \
      -v int_Column6Width=${int_Column6Width} \
      -v int_MaxShown=${int_MaxShown} 'BEGIN {
       FS = "_"
    }
    linenum <= int_MaxShown {
      printf Colour

      ## Check Owner of job
      ##system("echo " user
      ##system("echo grep ^str_Owner= "dir_Active"/$(basename "$0")")
      ##system("if [[ \"$(grep ^str_Owner="user" "dir_Active"/$(basename "$0") | cut -d"=" -f2-)\" ]] ; then printf \"*\" ; else printf \" \" ; fi")
      system("test -r \""dir_Active"/$(basename "$0").rules\" && printf \"R\"  || printf \" \"")
      printf "%3s", linenum
      system("test -r \""dir_Active"/$(basename "$0").pause\" && printf \"P|\" || printf \" |\"")

      if ( $2 != "" ) {
        printf "%7s|", $2
      }
      else {
        printf "%7s|", substr($3,1,7)
      }
      int_LogWidth=int_ScreenWidth - 7 - int_Column1Width - int_Column2Width - int_Column3Width \
                   - int_Column4Width  - int_Column5Width 
      ##printf "${dis_Reset}${str_StatusColour}%${int_Column1Width}s "   "${int_Count}${str_ID}"
      printf "%"int_Column3Width"s|%"int_Column4Width"s|%"int_Column5Width"s|",$4,$5,$6

      if ( state == "running" ) {
#       system("date -d \"1970-01-01 + $seconds seconds\" \"+%Hh%Mm%Ss\"")
#       printf '%02dh:%02dm:%02ds\n' $(($secs/3600)) $(($secs%3600/60)) $(($secs%60))
# Looking for the last AUDIT:START point
        cmd = "grep ^AUDIT:START "dir_Log"/$(basename "$0").log | tail -1 | cut -d: -f3"
        cmd | getline starttime
        cmd = "date +%s"
        cmd | getline currenttime
        secs = currenttime - starttime
        close(cmd)
        printf "%02d:%02d:%02d", secs/3600, secs%3600/60, secs%60
        printf "|"
        int_LogWidth = int_LogWidth - 9
      }
      system("echo $(tail -1 "dir_Log"/$(basename "$0").log 2>/dev/null | tr -cd \"\\011\\012\\040-\\254\" | cut -c1-"int_LogWidth")")
#     system("echo $(tail -1 "dir_Log"/$(basename "$0").log 2>/dev/null)")
      system("echo arr_States["linenum"]="state" >> "file_Cache)
      system("echo arr_Jobs["linenum"]=$(basename "$0") >> "file_Cache)

      linenum++
    }
    END {
      system("echo int_Count="linenum" >> "file_Cache )
    }'
    ##. ${file_Cache}
#       cat "${file_Cache}"
    [[ -r "${file_Cache}" ]] && . "${file_Cache}" && rm "${file_Cache}"
  done
}
#readonly -f fn_ShowJobs2

fn_DisplayTime()
{

  local int_Time=$1
  local int_Time2=${2:-}
  [ ! -z $int_Time2 ] && int_Time=$((int_Time2-int_Time))
  local int_Days=$((int_Time/60/60/24))
  local int_Hours=$((int_Time/60/60%24))
  local int_Minutes=$((int_Time/60%60))
  local int_Seconds=$((int_Time%60))

  if [[ ${int_Days} != 0 ]] ; then
    printf '%dd%02d:%02d:%02d\n' $int_Days $int_Hours $int_Minutes $int_Seconds
  else
    printf '%02d:%02d:%02d\n' $int_Hours $int_Minutes $int_Seconds
  fi
}

fn_ShowJobs3()
{
  ## Show job details for each job state past. The value passed is one or more directory names
  ## =========================================================================================
  typeset local str_EachJobState= arr_JobList= str_StatusColour=""
  typeset local str_StatusColour="${dis_Reset}"

  ## Due to the fact that directories may contain "spaces" so "cd" there first
  ## =========================================================================
  cd "${dir_Job}"
  int_Count=1

  find -L ${@} -type l

  file_Cache=$(mktemp "${dir_Tmp}"/cache.$$.XXXXX)
  echo "#$$" > "${file_Cache}"
  int_ScreenWidth=$(echo ${COLUMNS})
  int_ScreenWidth=$(tput cols)
  for str_State in ${@} ; do
  #  printf "${dis_Reset}"

    [[ "${str_State}" = "failed"  ]] && str_StatusColour="${dis_BRed}" || str_StatusColour="${dis_Reset}"
    [[ "$(ls ${str_State}/${str_JobPrefix}* 2>/dev/null)" ]] && fn_ShowLine "-" "$(echo ${str_State} | tr [:lower:] [:upper:])"
        [[ "${str_State}" != "completed" ]] && str_Reverse="r" || str_Reverse=""
#       echo $int_ScreenWidth
#echo "$(pwd)"
#echo "${file_Cache}"
    ls -${str_Reverse}t "${str_State}/${str_JobPrefix}"* 2>/dev/null | grep -v "pause$" | ${cmd_AWK} \
      -v            state=${str_State} \
      -v             user=${str_User} \
      -v          linenum=${int_Count} \
      -v          dir_Log="${dir_Log}" \
      -v       dir_Active="${dir_Active}" \
      -v       file_Cache="${file_Cache}" \
      -v           Colour=${str_StatusColour} \
      -v  int_ScreenWidth=${int_ScreenWidth} \
      -v int_Column1Width=${int_Column1Width} \
      -v int_Column2Width=${int_Column2Width} \
      -v int_Column3Width=${int_Column3Width} \
      -v int_Column4Width=${int_Column4Width} \
      -v int_Column5Width=${int_Column5Width} \
      -v int_Column6Width=${int_Column6Width} \
      -v int_MaxShown=${int_MaxShown} 'BEGIN {
       FS = "_"
    }
    linenum <= int_MaxShown {
      printf Colour

      ## Check Owner of job
      system("test -r \""dir_Active"/$(basename "$0").rules\" && printf \"R\"  || printf \" \"")
      printf "%3s", linenum
      system("test -r \""dir_Active"/$(basename "$0").pause\" && printf \"P|\" || printf \" |\"")

      if ( $2 != "" ) {
        printf "%7s|", $2
      }
      else {
        printf "%7s|", substr($3,1,7)
      }
      int_LogWidth=int_ScreenWidth - 7 - int_Column1Width - int_Column2Width - int_Column3Width \
                   - int_Column4Width  - int_Column5Width
      printf "%"int_Column3Width"s|%"int_Column4Width"s|%"int_Column5Width"s|",$4,$5,$6
      system("echo $(tail -1 "dir_Log"/$(basename "$0").log 2>/dev/null | tr -cd \"\\011\\012\\040-\\254\" | cut -c1-"int_LogWidth")")
#      system("echo $(tail -1 "dir_Log"/$(basename "$0").log 2>/dev/null)")
      system("echo arr_States["linenum"]="state" >> "file_Cache)
      system("echo arr_Jobs["linenum"]=$(basename "$0") >> "file_Cache)

      linenum++
    }
    END {
      system("echo int_Count="linenum" >> "file_Cache )
    }'
    ##. ${file_Cache}
#       cat "${file_Cache}"
    [[ -r "${file_Cache}" ]] && . "${file_Cache}" && rm "${file_Cache}"
  done
}
readonly -f fn_ShowJobs3


fn_FormatTasks()
{
  ## This function is only called by fn_ShowTasks and will format the layout
  ## regardless of whether the tasks were requested from a group call
  typeset local file_Job="${1}"
  typeset local file_Log="${dir_Log}/$(basename ${file_Job}).log"
  typeset local int_RefreshRate=${int_Refresh}
  # Fake the running state to start with a loop
  typeset local str_TmpJobState=$(basename $(dirname $(find -L ${dir_Job} -name $(basename ${file_Job}) -print| grep -v ${dir_Active} )))
  str_JobState=${str_TmpJobState}
  echo "${str_JobState} = ${str_TmpJobState}" 
  while [ "${str_JobState}" = "${str_TmpJobState}" ] ; do
    ${cmd_CLEAR}
    fn_ShowTop
    fn_ShowLine
    str_JobState=$(basename $(dirname $(find -L ${dir_Job} -name $(basename ${file_Job}) -print| grep -v ${dir_Active} )))

    printf "\n\n   "
    ls -lL "${file_Job}"
    [[ -z ${str_JobState} ]] && str_JobState=$(basename $(dirname $(find-L ${dir_Job} -name $(basename ${file_Job}) -print| grep -v ${dir_Active} )))
    case ${str_JobState} in
      queued  | pending | new ) int_Task=$(grep "^int_ResumePoint=" ${file_Job} | head -1 | cut -d"=" -f2) ;;
      failed  | fixing        ) int_Task=$(grep "Resume point:" ${dir_Log}/$(basename ${file_Job}).log | tail -1 | awk -F":" '{print $NF}') ;;
      running                 ) int_Task=$(grep "[0-9]*-[0-9]* Starting task" ${dir_Log}/$(basename ${file_Job}).log | tail -1 | cut -d"[" -f2 | cut -d"/" -f1 ) ;;
      completed               ) int_Task=$(grep "[0-9]*-[0-9]* Completed task \[" ${dir_Log}/$(basename ${file_Job}).log | tail -1 | cut -d"[" -f2- | cut -d"/" -f1); (( int_Task++ )) ;;
    esac
    # [ $DEBUG ] && echo "str_JobState: ${str_JobState} int_Task: ${int_Task:-0}"

printf "\n"
cat "${file_Job}" | ${cmd_AWK} -v int_Task=${int_Task} '
  BEGIN {
    linenum=1
    FS="\t"
  }

  $0 != "" { 
    if ( $1 ~ "^AUDIT:T") {
      split($1,task_tmp,":")

      # switch turned off due to issues with some nix versions
      #switch (task_tmp[4]) {
      #  case "R":
      #    str_Progress = " >>>  " 
      #    break
      #  case "C":
      #    str_Progress = "[done]"
      #    break
      #  case "F":
      #    str_Progress = "[fail]"
      #    break
      #  default:
      #    str_Progress = "  ??? "
      #    break
      #}

      if ( task_tmp[4] == "R")      str_Progress="  >>>   "
      if ( task_tmp[4] == "C")      str_Progress="[ done ]"
      if ( task_tmp[4] == "F")      str_Progress="[ fail ]"
      if ( task_tmp[4] == "S")      str_Progress="[ skip ]"
      if ( task_tmp[4] == "M")      str_Progress="[manual]"
      arr_Progress[task_tmp[3]]=str_Progress
    }
    if ( $1 ~ "^fn_Task_[1-9]") {
      str_Task=$2
      if ( str_Task != "" ) {
        if ( $1 ~ "SubTask" )      { 
        arr_SubTask[linenum] = "     . "        } else { arr_SubTask[linenum]=""}


      arr_Task[linenum]=str_Task
      #arr_Last=system("echo hello")

      #arr_Last=system("echo $(tail -1 "dir_Log"/$(basename "$0").log 2>/dev/null | tr -cd \"\\011\\012\\040-\\254\" | cut -c1-"int_LogWidth")")

      linenum++
    } }
  }
  END {
    linenum--

    for (int_Task=1; int_Task <= linenum ; int_Task++) {
      printf "%4s : %8s %s %s\n", int_Task, arr_Progress[int_Task], arr_SubTask[int_Task],arr_Task[int_Task] 
    }

  }
'

    #fn_PressEnter
    fn_ShowLine
    tail -${int_Tail} ${dir_Log}/$(basename ${file_Job}).log
	  printf " "
    fn_ShowLine "="

# TEST
#echo test
#int_Last=$(grep int_Last= ${file_Job} | tail -1 | cut -d= -f2)
#echo ${int_Last}
#for int_Count in $(seq 1  ${int_Last}) ; do
#  if (( int_Last = int_Count )) ; then
#    printf " >>>>  "
#  elif (( int_Last < int_Count )) ; then
#    printf "       "
#  else
#    printf "[done] "
#  fi

#  printf "${int_Count}: $(grep "AUDIT:T:${int_Count}" ${file_Job} | tail -1 | cut -d":" -f4) :"
  # tail shows sub tasks
#  grep fn_Task_${int_Count} ${file_Job} | tail -1 | cut -f2
#done
fn_ShowLine "="

    printf "\n\n ${dis_ULOn}R${dis_ULOff}efresh Rate | ${dis_ULOn}P${dis_ULOff}ause | e${dis_ULOn}X${dis_ULOff}it : "
    read ${str_Quick} -t ${int_RefreshRate} char_Choice

    case ${char_Choice} in
      r | R ) printf "\n\n Enter new refresh rate in seconds: " ; read -e int_NewRefreshRate
              if fn_IsNumber $int_NewRefreshRate ; then
                int_RefreshRate=${int_NewRefreshRate}
              else
                printf "\n An integar is expected for the refresh rate."
                sleep 2
              fi
              ;;
	    p | P ) fn_PressEnter ;;
	    x | X ) break ;;
    esac

  done
}
readonly -f fn_FormatTasks

fn_ShowTasks()
{
  ## This functions simply displays the list of tasks that will be run
  ## If a value was passed assume that was the job for which to show the tasks
  typeset local file_Job="${1}"
  typeset local int_Answer=

  fn_ShowTop
  fn_ShowLine

  if [[ "${file_Job}" ]] ; then
    fn_FormatTasks "${file_Job}"
  else
    printf "\n Display tasks for which job(s)?\n\n"

    #fn_ShowJobs2 superseded starting failed fixing queued pending new running completed
    fn_ShowJobs superseded starting failed fixing queued pending new running completed
    fn_ShowLine
    fn_GetAnswer range
    str_Answer=$(fn_Range "${str_Answer}")

    if [ "${str_Answer}" != "x" ] ; then
      for int_Answer in ${str_Answer} ; do
        if [[ ${int_Answer} -le 0 ]] || [[ ${int_Answer} -ge ${int_Count} ]] ; then
          printf "Out of range"
          fn_PressEnter
          return 0
        fi

        ## awk replaces
        ##   grep "#${str_ProgramName}_Task" "${dir_Job}"/${arr_States[${int_Answer}]}/${arr_Jobs[${int_Answer}]} | rev | cut -d">" -f4- | rev | more
        fn_FormatTasks "${dir_Active}/${arr_Jobs[${int_Answer}]}"
      done
    else
      echo "Nothing chosen"
      fn_PressEnter
    fi
  fi
}
readonly -f fn_ShowTasks

fn_JobInfo()
{
      ${cmd_CLEAR}
      fn_ShowTop
      fn_ShowLine "-" "Job Details"
      typeset local str_JobOwner=$(grep ^str_Owner "${file_ActiveJob}")
      echo " ${str_JobOwner}"
      echo " State at selection : ${str_JobState}"
          basename ${file_ActiveJob}
          ##pgrep -a ${$(basename ${file_ActiveJob})::15}
          [[ "${str_JobState}" = "running" ]] && pgrep -l $(basename ${file_ActiveJob})

      echo ""
      ls -lL "${file_ActiveJob}"
      ls -lL "${file_Log}"
      echo ""
          fn_ShowRules
          fn_ShowLine "-" "Template"
          sed -n -e '/^# Template Begin$/,/^# Template End$/{//!p}' "${file_ActiveJob}"
          echo ""
      fn_ShowLine "-" "Log Summary "
      tail -${int_Tail} "${file_Log}"
      echo ""
      fn_ShowLine "-"
      printf "\n${dis_Reset}"
}

fn_ContextMenu()
{
  ## A context-based menu based on the state of jobs
  ## Used in two ways....
  ##    specific mode (where a directory name is passed)
  ## and
  ##    generic mode (where it caters for all directories)

  typeset local str_State=${1:-}

  typeset local b_QueuedJobs=
  typeset local b_FailedJobs=
  typeset local b_NewJobs=
  typeset local b_RunningJobs=
  typeset local b_Plugins=
  ##  printf "\n\n${dis_Reset}"
  if [[ "${str_State}" ]] ; then
    ## Specific Mode
    printf " ${dis_ULOn}V${dis_ULOff}iew | ${dis_ULOn}E${dis_ULOff}dit | ${dis_ULOn}L${dis_ULOff}og | ${dis_ULOn}tail${dis_ULOff} | "
    case ${str_State} in
      queued  | pending ) b_QueuedJobs=1 ;;
      failed            ) b_FailedJobs=1 ;;
      fixing            ) b_FailedJobs=1 ;;
      new               ) b_NewJobs=1 ;;
      running           ) b_RunningJobs=1 ;;
    esac
  else
    ## Generic Mode
    if [[ "$hex_MD5" != "$(md5sum ${dir_Base}/${str_ProgramName}| cut -d" " -f1)" ]] ; then
      printf " Update available - please restart\n\n"
    fi

    printf " ${dis_ULOn}N${dis_ULOff}ew | "
    #[[ "$(ls \"${dir_Lock}\" 2>/dev/null)" ]] && printf "${dis_ULOn}L${dis_ULOff}ock | "
    #echo "echo ${arr_States[@]} | grep -i queued)"
    [[ "$(echo ${arr_States[@]} | egrep -i "queued|pending")"  ]] && b_QueuedJobs=1
    [[ "$(echo ${arr_States[@]} | egrep -i "running|pending")" ]] && b_RunningJobs=1
    [[ "$(echo ${arr_States[@]} |  grep -i new)"               ]] && b_NewJobs=1
    [[ "$(echo ${arr_States[@]} |  grep -i failed)"            ]] && b_FailedJobs=1 && b_NewJobs=1
    [[ "$(echo ${arr_States[@]} |  grep -i fixing)"            ]] && b_FailedJobs=1 && b_NewJobs=1
    [[ "${ENTERPRISE}" ]] && b_Plugins=1
    #printf "${dis_ULOn}C${dis_ULOff}SV | "

  fi

  [[ "${b_QueuedJobs}"  ]]                                && printf "${dis_ULOn}U${dis_ULOff}nqueue | "
  [[ "${b_RunningJobs}" ]]  || [[ "${b_QueuedJobs}" ]]    && printf "${dis_ULOn}P${dis_ULOff}ause | "
  [[ "${b_FailedJobs}"  ]]                                && printf "${dis_ULOn}R${dis_ULOff}esume | "
  [[ "${b_FailedJobs}"  ]]  && [ "${str_State}" ]         && printf "${dis_ULOn}F${dis_ULOff}IP | ${dis_ULOn}S${dis_ULOff}kip | "
  [[ "${b_NewJobs}"     ]]                                && printf "${dis_ULOn}Q${dis_ULOff}ueue | "
  #[[ "${str_State}"     ]]                                || printf "${dis_ULOn}M${dis_ULOff}OTD | "
  [[ "${arr_Jobs[1]}"   ]]  || [[ "${str_State}" ]]       && printf "${dis_ULOn}T${dis_ULOff}asks | "
  ( [[ "${b_FailedJobs}" ]] || [[ "${b_RunningJobs}" ]] ) && [[ "${str_State}" ]]  && printf "${dis_ULOn}C${dis_ULOff}ancel | "

  printf "${dis_ULOn}A${dis_ULOff}dmin | e${dis_ULOn}X${dis_ULOff}it : "

}
readonly -f fn_ContextMenu

## End
