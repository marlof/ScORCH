##
## Copyright 2016 WebMarcIT Ltd
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
##    http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##

## This file contains functions to set and display layout
## fn_SetLayout()
## fn_ShowTop()
## fn_ShowLine()
## fn_DisplayTime()
## fn_FormatTasks()
## fn_ShowTasks()
## fn_JobInfo()
## fn_ContextMenu()


fn_SetLayout()
{
  ## Define the bounds of the screen
  ## The default screen layout is broken into columns to split up job names into
  ## meaningful groups
  ##
  ##  C1|     C2|        C3|        C4|
  ##==========================================================
  ##    |       |          |          |
  int_ScreenWidth=$(${cmd_TPUT} cols)
  ## echo ${int_ScreenWidth}
  #int_ScreenWidth=${COLUMNS}

  # Purposely set one per line to cope with white space in directory names
  arr_Checks="
    ${dir_New}
    ${dir_Completed}
    ${dir_Failed}
    ${dir_Running}"

  int_Column1Width=4        # Selection number
  int_Column2Width=8        # System reference number (like JIRA) or use ticket number
  SAVEIFS=$IFS
  IFS=$(echo -en "\n\b")
  (( int_Column3Width=$(find -L ${dir_Active}                   | ${cmd_AWK} -F"_" '{print length($4)}' | sort -un | tail -1) +1 ))
  (( int_Column4Width=$(find -L ${dir_Active}                   | ${cmd_AWK} -F"_" '{print length($5)}' | sort -un | tail -1) +1 ))
  (( int_Column5Width=$(find -L ${dir_Active} ! -name "*.rules" | ${cmd_AWK} -F"_" '{print length($6)}' | sort -un | tail -1) +1 ))
  (( int_Column6Width=$(find -L ${dir_Active}                   | ${cmd_AWK} -F"_" '{print length($7)}' | sort -un | tail -1) +1 ))
  IFS=$SAVEIFS
#int_Column2Width=16
#int_Column3Width=12 #${int_Column3Width:-20}       # The Action / Plugin
#int_Column4Width=10       # The Environment performed on
#int_Column5Width=10       # The Version / Release being actioned
#int_Column6Width=10       # Available

  int_Column7Width=10       # The Log
  cha_ColumnSep="|"
}
readonly -f fn_SetLayout


fn_ShowTop()
{
  [[ ! -z $b_NonInteractive ]] && return
  ## Display the name of the program and any interesting facts about the environment
  ## ===============================================================================
  typeset local int_TitleWidth
  [[ -z ${int_Column1Width} ]] && int_Column1Width=10
  [[ -z ${int_Column2Width} ]] && int_Column2Width=10
  (( int_TitleWidth=${int_Column1Width} + ${int_Column2Width} ))
  ${cmd_CLEAR}

  ## Check the current width of the screen
  ## =====================================
  int_ScreenWidth=$(${cmd_TPUT} cols)
  #int_ScreenWidth=${COLUMNS}
  ##(( int_DateLocation=${int_ScreenWidth} - ${int_TitleWidth} - ${int_Column2Width} - ${int_Column3Width} - 20 ))
  (( int_DatePut = ${int_ScreenWidth} - 21 ))

  int_DiskUsage_tmp=$(df "${dir_Base}" | tail -1)
  int_DiskUsage="$(echo ${int_DiskUsage_tmp%\%*} | ${cmd_AWK} -F" " '{print $NF}')"
  str_DiskUsage=$int_DiskUsage
  (( int_DiskUsage >= 80 )) && str_DiskUsage="${dis_FYellow}${int_DiskUsage}${dis_Reset}" 
  (( int_DiskUsage >= 90 )) && str_DiskUsage="${dis_FRed}${int_DiskUsage}${dis_Reset}"
  
  #echo "${int_DiskUsage}%"
  ## Collect disk usage to display
  ##int_DiskUsage=$(df "${dir_Base}" |  ${cmd_AWK} 'NR==2 {sub(/%/,""); if ($5 > 44 ) print ""$5"" else print $5}')
  #int_DiskUsage=$(df "${dir_Base}" |  ${cmd_AWK} 'NR==2 {sub(/%/,""); if ($5 > 80 ) {
  #                                      print "${dis_FRed}"$5"%${dis_Reset}" }
  #                                        else {
  #                                          print $5"%"
  #                                                                        }
  #                                    printf "" }')
  ## Output the program name, the dispatcher PID and the date
  typeset int_DispatcherPID=$(ls -l "${file_DispatchLock}" 2>/dev/null | ${cmd_AWK} -F"_" '{print $NF}')
  int_DispatcherPID=${int_DispatcherPID:-0}
  printf "  %${int_TitleWidth}s|%${int_Column3Width}s|%${int_Column4Width}s|%${int_Column6Width}s|%s" \
         "${str_ProgramName} [${str_ProgramVersion}]" \
         "D:${int_DispatcherPID}" \
         "df:${str_DiskUsage}%" "${str_License}" "${str_Authority}"
  [[ ${cmd_TPUT} != "echo" ]] && tput cup 0 ${int_DatePut} ; echo "$(date +'%D %T')"


  ## Reset the Array for Jobs and States
  ## ===================================
  unset arr_Jobs arr_States
}
readonly -f fn_ShowTop

fn_ShowLine()
{
  ## Show a line of dashes unless a different character is past or character and title is passed

  ## Check if parameters have been past
  ## ==================================
  typeset local cha_LineChar=${1:-"-"}
  typeset local str_LineTitle=${2:-$cha_LineChar}

  ## Find the width of the title
  ## ===========================
  typeset local int_LineTitleWidth=$(echo ${str_LineTitle} | wc -c)

  ## Set the number of characters required to the correct width
  ## ==========================================================
  (( int_DisplayWidth = ${int_ScreenWidth}-${int_LineTitleWidth} - 4 ))
  printf "${dis_Reset}   ${str_LineTitle} %${int_DisplayWidth}s\n" | sed "s/ /${cha_LineChar}/g"

}
readonly -f fn_ShowLine

fn_ShowJobs()
{
    if [ -f ${dir_Python}/showJobs.py ] ; then
      [[ ! -z ${str_Filter} ]] && fn_ShowLine "=" "Filter ${str_Filter}"
      ${dir_Python}/showJobs.py -n $int_MaxShown -o ${file_Cache} -f "${str_Filter}" $* 
      [[ -r ${file_Cache} ]] && . ${file_Cache}
    else
      fn_ShowJobs2
    fi
}

fn_DisplayTime()
{

  local int_Time=$1
  local int_Time2=${2:-}
  [ ! -z $int_Time2 ] && int_Time=$((int_Time2-int_Time))
  local int_Days=$((int_Time/60/60/24))
  local int_Hours=$((int_Time/60/60%24))
  local int_Minutes=$((int_Time/60%60))
  local int_Seconds=$((int_Time%60))

  if [[ ${int_Days} != 0 ]] ; then
    printf '%dd%02d:%02d:%02d\n' $int_Days $int_Hours $int_Minutes $int_Seconds
  else
    printf '%02d:%02d:%02d\n' $int_Hours $int_Minutes $int_Seconds
  fi
}

fn_FormatTasks()
{
  ## This function is only called by fn_ShowTasks and will format the layout
  ## regardless of whether the tasks were requested from a group call
  typeset local file_Job="${1}"
  typeset local file_Log="${dir_Log}/$(basename ${file_Job}).log"
  typeset local int_RefreshRate=${int_Refresh}
  # Fake the running state to start with a loop
  typeset local str_TmpJobState=$(basename $(dirname $(find -L ${dir_Job} -name $(basename ${file_Job}) -print| grep -v ${dir_Active} )))
  str_JobState=${str_TmpJobState}
  echo "${str_JobState} = ${str_TmpJobState}" 
  while [ "${str_JobState}" = "${str_TmpJobState}" ] ; do
    ${cmd_CLEAR}
    fn_ShowTop
    fn_ShowLine
    str_JobState=$(basename $(dirname $(find -L ${dir_Job} -name $(basename ${file_Job}) -print| grep -v ${dir_Active} )))

    printf "\n\n   "
    ls -lL "${file_Job}"
    [[ -z ${str_JobState} ]] && str_JobState=$(basename $(dirname $(find-L ${dir_Job} -name $(basename ${file_Job}) -print| grep -v ${dir_Active} )))
    case ${str_JobState} in
      queued  | pending | new ) int_Task=$(grep "^int_ResumePoint=" ${file_Job} | head -1 | cut -d"=" -f2) ;;
      failed  | fixing        ) int_Task=$(grep "Resume point:" ${dir_Log}/$(basename ${file_Job}).log | tail -1 | awk -F":" '{print $NF}') ;;
      running                 ) int_Task=$(grep "[0-9]*-[0-9]* Starting task" ${dir_Log}/$(basename ${file_Job}).log | tail -1 | cut -d"[" -f2 | cut -d"/" -f1 ) ;;
      completed               ) int_Task=$(grep "[0-9]*-[0-9]* Completed task \[" ${dir_Log}/$(basename ${file_Job}).log | tail -1 | cut -d"[" -f2- | cut -d"/" -f1); (( int_Task++ )) ;;
    esac
    # [ $DEBUG ] && echo "str_JobState: ${str_JobState} int_Task: ${int_Task:-0}"

printf "\n"
cat "${file_Job}" | ${cmd_AWK} -v int_Task=${int_Task} '
  BEGIN {
    linenum=1
    FS="\t"
  }

  $0 != "" { 
    if ( $1 ~ "^AUDIT:T") {
      split($1,task_tmp,":")

      if ( task_tmp[4] == "R")      str_Progress="  >>>  "
      if ( task_tmp[4] == "C")      str_Progress="[ done ]"
      if ( task_tmp[4] == "F")
       {    str_Progress="[ fail ]"   }
      if ( task_tmp[4] == "S")      str_Progress="[ skip ]"
      if ( task_tmp[4] == "M")      str_Progress="[manual]"
      arr_Progress[task_tmp[3]]=str_Progress
    }
    if ( $1 ~ "^fn_Task_[1-9]") {
      str_Task=$2
      if ( str_Task != "" ) {
        if ( $1 ~ "SubTask" )      { 
          arr_SubTask[linenum] = "     . "        } else { arr_SubTask[linenum]=""}

      arr_Task[linenum]=str_Task
      linenum++
    } }
  }
  END {
    linenum--

    for (int_Task=1; int_Task <= linenum ; int_Task++) {
      printf "%4s : %8s %s %s\n", int_Task, arr_Progress[int_Task], arr_SubTask[int_Task],arr_Task[int_Task] 
    }

  }
'

    #fn_PressEnter
    fn_ShowLine
    tail -${int_Tail} ${dir_Log}/$(basename ${file_Job}).log
	  printf " "
    fn_ShowLine "="

    printf "\n\n ${dis_ULOn}R${dis_ULOff}efresh Rate | ${dis_ULOn}P${dis_ULOff}ause | e${dis_ULOn}X${dis_ULOff}it : "
    read ${str_Quick} -t ${int_RefreshRate} char_Choice

    case ${char_Choice} in
      r | R ) printf "\n\n Enter new refresh rate in seconds: " ; read -e int_NewRefreshRate
              if fn_IsNumber $int_NewRefreshRate ; then
                int_RefreshRate=${int_NewRefreshRate}
              else
                printf "\n An integar is expected for the refresh rate."
                sleep 2
              fi
              ;;
	    p | P ) fn_PressEnter ;;
	    x | X ) break ;;
    esac

  done
}
readonly -f fn_FormatTasks

fn_ShowTasks()
{
  ## This functions simply displays the list of tasks that will be run
  ## If a value was passed assume that was the job for which to show the tasks
  typeset local file_Job="${1}"
  typeset local int_Answer=

  fn_ShowTop
  fn_ShowLine

  if [[ "${file_Job}" ]] ; then
    fn_FormatTasks "${file_Job}"
  else
    printf "\n Display tasks for which job(s)?\n\n"

    fn_ShowJobs superseded manual starting failed fixing queued pending new running completed
    fn_ShowLine
    fn_GetAnswer range
    str_Answer=$(fn_Range "${str_Answer}")

    if [ "${str_Answer}" != "x" ] ; then
      for int_Answer in ${str_Answer} ; do
        if [[ ${int_Answer} -le 0 ]] || [[ ${int_Answer} -ge ${int_Count} ]] ; then
          printf "Out of range"
          fn_PressEnter
          return 0
        fi

        fn_FormatTasks "${dir_Active}/${arr_Jobs[${int_Answer}]}"
      done
    else
      echo "Nothing chosen"
      fn_PressEnter
    fi
  fi
}
readonly -f fn_ShowTasks

fn_JobInfo()
{
  ${cmd_CLEAR}
  fn_ShowTop
  fn_ShowLine "-" "Job Details"
  typeset local str_JobOwner=$(grep ^str_Owner "${file_ActiveJob}")
  echo " ${str_JobOwner}"
  echo " State at selection : ${str_JobState}"
  basename ${file_ActiveJob}
  ##pgrep -a ${$(basename ${file_ActiveJob})::15}
  [[ "${str_JobState}" = "running" ]] && pgrep -l $(basename ${file_ActiveJob})
  echo ""
  ls -lL "${file_ActiveJob}"
  ls -lL "${file_Log}"
  echo ""
  fn_ShowRules
  fn_ShowLine "-" "Template"
  sed -n -e '/^# Template Begin$/,/^# Template End$/{//!p}' "${file_ActiveJob}"
  echo ""
  fn_ShowLine "-" "Log Summary"
  tail -${int_Tail} "${file_Log}"
  echo ""
  if [[ "${str_JobState}" = "completed" ]] ; then
    fn_ShowLine "-" "Issues"
    grep "REASON:" ${file_ActiveJob}
  fi
  fn_ShowLine "-" 

  printf "\n${dis_Reset}"
}

fn_ContextMenu()
{
  ## A context-based menu based on the state of jobs
  ## Used in two ways....
  ##    specific mode (where a directory name is passed)
  ## and
  ##    generic mode (where it caters for all directories)

  typeset local str_State=${1:-}

  typeset local b_QueuedJobs=
  typeset local b_FailedJobs=
  typeset local b_NewJobs=
  typeset local b_RunningJobs=
  typeset local b_Plugins=
  ##  printf "\n\n${dis_Reset}"
  if [[ "${str_State}" ]] ; then
    ## Specific Mode
    printf " ${dis_ULOn}V${dis_ULOff}iew | ${dis_ULOn}E${dis_ULOff}dit | ${dis_ULOn}L${dis_ULOff}og | ${dis_ULOn}tail${dis_ULOff} | "
    case ${str_State} in
      queued  | pending ) b_QueuedJobs=1 ;;
      failed  | manual  ) b_FailedJobs=1 ;;
      fixing            ) b_FailedJobs=1 ;;
      new               ) b_NewJobs=1 ;;
      running           ) b_RunningJobs=1 ;;
    esac
  else
    ## Generic Mode
    if [[ "$hex_MD5" != "$(md5sum ${dir_Base}/${str_ProgramName}| cut -d" " -f1)" ]] ; then
      printf " Update available - please restart\n\n"
    fi

    printf " ${dis_ULOn}N${dis_ULOff}ew | "
    [[ "$(echo ${arr_States[@]} | egrep -i "queued|pending")"  ]] && b_QueuedJobs=1
    [[ "$(echo ${arr_States[@]} | egrep -i "running|pending")" ]] && b_RunningJobs=1
    [[ "$(echo ${arr_States[@]} |  grep -i new)"               ]] && b_NewJobs=1
    [[ "$(echo ${arr_States[@]} | egrep -i "failed|manual")"   ]] && b_NewJobs=1 && b_FailedJobs=1 
    [[ "$(echo ${arr_States[@]} |  grep -i fixing)"            ]] && b_NewJobs=1 && b_FailedJobs=1
    [[ "${ENTERPRISE}" ]] && b_Plugins=1
  fi

  [[ "${b_QueuedJobs}"  ]]                                && printf "${dis_ULOn}U${dis_ULOff}nqueue | "
  [[ "${b_RunningJobs}" ]]  || [[ "${b_QueuedJobs}" ]]    && printf "${dis_ULOn}P${dis_ULOff}ause | "
  [[ "${b_FailedJobs}"  ]]                                && printf "${dis_ULOn}R${dis_ULOff}esume | "
  [[ "${b_FailedJobs}"  ]]  && [ "${str_State}" ]         && printf "${dis_ULOn}F${dis_ULOff}IP | ${dis_ULOn}S${dis_ULOff}kip | "
  [[ "${b_NewJobs}"     ]]  || [[ "${b_FailedJobs}"  ]]   && printf "${dis_ULOn}Q${dis_ULOff}ueue | "
  [[ "${arr_Jobs[1]}"   ]]  || [[ "${str_State}" ]]       && printf "${dis_ULOn}T${dis_ULOff}asks | "
  ( [[ "${b_FailedJobs}" ]] || [[ "${b_RunningJobs}" ]] ) && [[ "${str_State}" ]]  && printf "${dis_ULOn}H${dis_ULOff}angup | "
  [[ "${b_NewJobs}"     ]]                                && printf "${dis_ULOn}D${dis_ULOff}elete | "

  [[ ! "${str_State}" ]]  && printf "${dis_ULOn}A${dis_ULOff}dmin | "
  printf "${dis_ULOn}F${dis_ULOff}ilter | e${dis_ULOn}X${dis_ULOff}it : "

}
readonly -f fn_ContextMenu

## End
